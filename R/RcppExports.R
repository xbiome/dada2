# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

C_is_bimera <- function(sq, pars, allow_one_off, min_one_off_par_dist, match, mismatch, gap_p, max_shift) {
    .Call('_dada2_C_is_bimera', PACKAGE = 'dada2', sq, pars, allow_one_off, min_one_off_par_dist, match, mismatch, gap_p, max_shift)
}

C_table_bimera2 <- function(mat, seqs, min_fold, min_abund, allow_one_off, min_one_off_par_dist, match, mismatch, gap_p, max_shift) {
    .Call('_dada2_C_table_bimera2', PACKAGE = 'dada2', mat, seqs, min_fold, min_abund, allow_one_off, min_one_off_par_dist, match, mismatch, gap_p, max_shift)
}

C_nwalign <- function(s1, s2, match, mismatch, gap_p, homo_gap_p, band, endsfree) {
    .Call('_dada2_C_nwalign', PACKAGE = 'dada2', s1, s2, match, mismatch, gap_p, homo_gap_p, band, endsfree)
}

C_eval_pair <- function(s1, s2) {
    .Call('_dada2_C_eval_pair', PACKAGE = 'dada2', s1, s2)
}

C_pair_consensus <- function(s1, s2, prefer, trim_overhang) {
    .Call('_dada2_C_pair_consensus', PACKAGE = 'dada2', s1, s2, prefer, trim_overhang)
}

C_isACGT <- function(seqs) {
    .Call('_dada2_C_isACGT', PACKAGE = 'dada2', seqs)
}

kmer_dist <- function(s1, s2, kmer_size) {
    .Call('_dada2_kmer_dist', PACKAGE = 'dada2', s1, s2, kmer_size)
}

kord_dist <- function(s1, s2, kmer_size, SSE) {
    .Call('_dada2_kord_dist', PACKAGE = 'dada2', s1, s2, kmer_size, SSE)
}

kmer_matches <- function(s1, s2, kmer_size) {
    .Call('_dada2_kmer_matches', PACKAGE = 'dada2', s1, s2, kmer_size)
}

kdist_matches <- function(s1, s2, kmer_size) {
    .Call('_dada2_kdist_matches', PACKAGE = 'dada2', s1, s2, kmer_size)
}

C_matchRef <- function(seqs, ref, word_size, non_overlapping) {
    .Call('_dada2_C_matchRef', PACKAGE = 'dada2', seqs, ref, word_size, non_overlapping)
}

C_matrixEE <- function(inp) {
    .Call('_dada2_C_matrixEE', PACKAGE = 'dada2', inp)
}

C_nwvec <- function(s1, s2, match, mismatch, gap_p, band, endsfree) {
    .Call('_dada2_C_nwvec', PACKAGE = 'dada2', s1, s2, match, mismatch, gap_p, band, endsfree)
}

#' @useDynLib dada2
#' @importFrom Rcpp evalCpp
NULL

dada_uniques <- function(seqs, abundances, priors, err, quals, match, mismatch, gap, use_kmers, kdist_cutoff, band_size, omegaA, omegaP, omegaC, max_clust, min_fold, min_hamming, min_abund, use_quals, final_consensus, vectorized_alignment, homo_gap, multithread, verbose, SSE, gapless, greedy) {
    .Call('_dada2_dada_uniques', PACKAGE = 'dada2', seqs, abundances, priors, err, quals, match, mismatch, gap, use_kmers, kdist_cutoff, band_size, omegaA, omegaP, omegaC, max_clust, min_fold, min_hamming, min_abund, use_quals, final_consensus, vectorized_alignment, homo_gap, multithread, verbose, SSE, gapless, greedy)
}

C_assign_taxonomy <- function(seqs, rcs, refs, ref_to_genus, genusmat, try_rc, verbose) {
    .Call('_dada2_C_assign_taxonomy', PACKAGE = 'dada2', seqs, rcs, refs, ref_to_genus, genusmat, try_rc, verbose)
}

C_assign_taxonomy2 <- function(seqs, rcs, refs, ref_to_genus, genusmat, try_rc, verbose) {
    .Call('_dada2_C_assign_taxonomy2', PACKAGE = 'dada2', seqs, rcs, refs, ref_to_genus, genusmat, try_rc, verbose)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_dada2_RcppExport_registerCCallable', PACKAGE = 'dada2')
})
